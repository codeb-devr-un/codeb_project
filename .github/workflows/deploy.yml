name: Deploy WorkB CMS

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

env:
  APP_NAME: workb-cms
  NODE_VERSION: '20'
  PRODUCTION_URL: https://workb.net
  STAGING_URL: https://workb-staging.codeb.dev

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    name: Lint & Type Check
    runs-on: self-hosted
    if: github.event_name == 'pull_request' || github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache node_modules
        uses: actions/cache@v4
        id: cache-deps
        with:
          path: |
            node_modules
            ~/.npm
          key: deps-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            deps-${{ runner.os }}-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run ESLint
        run: npm run lint

      - name: Run Type Check
        run: npm run type-check

  test:
    name: Run Tests
    runs-on: self-hosted
    needs: lint
    if: |
      (github.event_name == 'pull_request' || github.event_name == 'push') &&
      github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache node_modules
        uses: actions/cache@v4
        id: cache-deps
        with:
          path: |
            node_modules
            ~/.npm
          key: deps-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            deps-${{ runner.os }}-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Run Tests
        run: npm test -- --passWithNoTests --coverage
        env:
          NODE_ENV: test

      - name: Upload Coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7

  build-deploy:
    name: Build & Deploy
    runs-on: self-hosted
    needs: [lint, test]
    if: |
      always() &&
      (needs.lint.result == 'success' || needs.lint.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped') &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    outputs:
      environment: ${{ steps.env.outputs.environment }}
      container_name: ${{ steps.vars.outputs.container_name }}
      port: ${{ steps.vars.outputs.port }}
      url: ${{ steps.vars.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set deployment variables
        id: vars
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          if [ "$ENV" = "production" ]; then
            echo "container_name=${{ env.APP_NAME }}" >> $GITHUB_OUTPUT
            echo "port=3200" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT
            echo "memory=2g" >> $GITHUB_OUTPUT
            echo "cpus=2" >> $GITHUB_OUTPUT
          else
            echo "container_name=${{ env.APP_NAME }}-staging" >> $GITHUB_OUTPUT
            echo "port=3201" >> $GITHUB_OUTPUT
            echo "image_tag=staging" >> $GITHUB_OUTPUT
            echo "url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT
            echo "memory=1g" >> $GITHUB_OUTPUT
            echo "cpus=1" >> $GITHUB_OUTPUT
          fi

      - name: Ensure network exists
        run: |
          NETWORK_NAME="workb-network"
          if ! podman network exists ${NETWORK_NAME} 2>/dev/null; then
            echo "Creating network ${NETWORK_NAME}..."
            podman network create ${NETWORK_NAME} || true
          fi
          echo "Network ${NETWORK_NAME} is ready"

      - name: Build image with Podman
        run: |
          echo "Building image for ${{ steps.env.outputs.environment }}..."

          # Set cgroup manager to cgroupfs for rootless podman in CI
          export PODMAN_CGROUP_MANAGER=cgroupfs

          podman build \
            --cgroup-manager=cgroupfs \
            --build-arg BUILDTIME=$(date -Iseconds) \
            --build-arg VERSION=${{ github.sha }} \
            --build-arg REVISION=${{ github.sha }} \
            --layers \
            -t localhost/${{ env.APP_NAME }}:${{ steps.vars.outputs.image_tag }} \
            -t localhost/${{ env.APP_NAME }}:${{ github.sha }} \
            .
          echo "Build complete!"
          podman images | grep ${{ env.APP_NAME }}

      - name: Create Quadlet configuration
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          PORT="${{ steps.vars.outputs.port }}"
          IMAGE_TAG="${{ steps.vars.outputs.image_tag }}"
          ENV="${{ steps.env.outputs.environment }}"
          MEMORY="${{ steps.vars.outputs.memory }}"
          CPUS="${{ steps.vars.outputs.cpus }}"
          APP_NAME="${{ env.APP_NAME }}"

          sudo mkdir -p /etc/containers/systemd

          # Create Quadlet file using printf to avoid heredoc issues
          printf '%s\n' \
            "[Unit]" \
            "Description=WorkB CMS Container (${ENV})" \
            "After=network-online.target" \
            "Wants=network-online.target" \
            "" \
            "[Container]" \
            "ContainerName=${CONTAINER_NAME}" \
            "Image=localhost/${APP_NAME}:${IMAGE_TAG}" \
            "PublishPort=${PORT}:3000" \
            "Network=workb-network" \
            "Environment=NODE_ENV=${ENV}" \
            "Environment=PORT=3000" \
            "Environment=HOSTNAME=0.0.0.0" \
            "EnvironmentFile=/etc/containers/systemd/${CONTAINER_NAME}.env" \
            "HealthCmd=curl -sf http://localhost:3000/api/health || exit 1" \
            "HealthInterval=30s" \
            "HealthTimeout=10s" \
            "HealthRetries=3" \
            "HealthStartPeriod=60s" \
            "PodmanArgs=--memory=${MEMORY} --cpus=${CPUS}" \
            "" \
            "[Service]" \
            "Restart=always" \
            "RestartSec=10" \
            "TimeoutStartSec=300" \
            "" \
            "[Install]" \
            "WantedBy=multi-user.target default.target" \
            | sudo tee /etc/containers/systemd/${CONTAINER_NAME}.container > /dev/null

          echo "Quadlet config created:"
          sudo cat /etc/containers/systemd/${CONTAINER_NAME}.container

      - name: Verify env file exists
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          ENV_FILE="/etc/containers/systemd/${CONTAINER_NAME}.env"

          if [ ! -f "$ENV_FILE" ]; then
            echo "Warning: Env file not found: $ENV_FILE"
            echo "Creating minimal env file..."
            printf '%s\n' \
              "# WorkB CMS Environment" \
              "NODE_ENV=production" \
              "PORT=3000" \
              | sudo tee "$ENV_FILE" > /dev/null
            echo "Please update $ENV_FILE with proper values!"
          else
            echo "Env file exists: $ENV_FILE"
            echo "Env file contents (sensitive values hidden):"
            sudo grep -v -E "(PASSWORD|SECRET|KEY|TOKEN)" "$ENV_FILE" || true
          fi

      - name: Stop existing container
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          echo "Stopping existing container..."
          sudo systemctl stop ${CONTAINER_NAME}.service 2>/dev/null || true
          sudo systemctl reset-failed ${CONTAINER_NAME}.service 2>/dev/null || true
          sudo podman stop ${CONTAINER_NAME} 2>/dev/null || true
          sudo podman rm -f ${CONTAINER_NAME} 2>/dev/null || true
          echo "Existing container stopped"

      - name: Reload systemd and start service
        id: deploy
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          echo "Deploying ${CONTAINER_NAME}..."

          sudo systemctl daemon-reload

          echo "Available service files:"
          sudo ls -la /run/systemd/generator/${CONTAINER_NAME}.service 2>/dev/null || echo "No generated service yet"

          if ! sudo systemctl start ${CONTAINER_NAME}.service; then
            echo "Service failed to start!"
            echo ""
            echo "=== systemctl status ==="
            sudo systemctl status ${CONTAINER_NAME}.service --no-pager -l || true
            echo ""
            echo "=== journalctl logs ==="
            sudo journalctl -xeu ${CONTAINER_NAME}.service --no-pager -n 100 || true
            echo ""
            echo "=== Quadlet file ==="
            sudo cat /etc/containers/systemd/${CONTAINER_NAME}.container || true
            echo ""
            echo "=== Env file (sanitized) ==="
            sudo grep -v -E "(PASSWORD|SECRET|KEY|TOKEN)" /etc/containers/systemd/${CONTAINER_NAME}.env 2>/dev/null || echo "No env file"
            echo ""
            echo "=== Podman images ==="
            sudo podman images | grep ${{ env.APP_NAME }} || true
            exit 1
          fi

          echo "Waiting for container to initialize..."
          sleep 15

      - name: Verify deployment
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          PORT="${{ steps.vars.outputs.port }}"
          MAX_RETRIES=10
          RETRY_COUNT=0

          echo "Container status:"
          sudo podman ps -a | grep ${CONTAINER_NAME} || true

          if ! sudo podman ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
            echo "Container is not running!"
            echo ""
            echo "=== Container logs ==="
            sudo podman logs ${CONTAINER_NAME} 2>&1 | tail -100 || true
            echo ""
            echo "=== Podman inspect ==="
            sudo podman inspect ${CONTAINER_NAME} 2>&1 | tail -50 || true
            exit 1
          fi

          echo "Container ${CONTAINER_NAME} is running!"
          echo ""
          echo "Waiting for health check..."

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            sleep 3
            response=$(curl -sf -o /dev/null -w "%{http_code}" http://localhost:${PORT}/api/health 2>/dev/null || echo "000")
            if [ "$response" = "200" ]; then
              echo "Health check passed! (attempt $((RETRY_COUNT + 1)))"
              break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES (status: $response)"
          done

          if [ "$response" != "200" ]; then
            echo "Health check failed after $MAX_RETRIES attempts"
            echo "Last response: $response"
            echo ""
            echo "=== Container logs ==="
            sudo podman logs ${CONTAINER_NAME} 2>&1 | tail -100
          fi

      - name: Enable service on boot
        run: |
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
          sudo systemctl enable ${CONTAINER_NAME}.service 2>/dev/null || true
          echo "Service enabled for auto-start"

      - name: Show deployment info
        if: always()
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          PORT="${{ steps.vars.outputs.port }}"
          URL="${{ steps.vars.outputs.url }}"
          CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"

          echo ""
          echo "=========================================="
          echo "Deployment Summary"
          echo "=========================================="
          echo "Environment: ${ENV}"
          echo "Container: ${CONTAINER_NAME}"
          echo "Image: localhost/${{ env.APP_NAME }}:${{ steps.vars.outputs.image_tag }}"
          echo "Port: ${PORT}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo ""
          echo "URL: ${URL}"
          echo ""
          echo "=== Service Status ==="
          sudo systemctl is-active ${CONTAINER_NAME}.service || true
          echo ""
          echo "=== Running Containers ==="
          sudo podman ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -E "(NAMES|${{ env.APP_NAME }})" || true

      - name: Cleanup old images
        if: success()
        run: |
          echo "Cleaning up old images..."
          sudo podman images localhost/${{ env.APP_NAME }} --format "{{.ID}} {{.CreatedAt}}" | \
            sort -k2 -r | tail -n +6 | awk '{print $1}' | \
            xargs -r sudo podman rmi 2>/dev/null || true
          sudo podman image prune -f 2>/dev/null || true
          echo "Cleanup complete!"

  notify:
    name: Send Notification
    runs-on: self-hosted
    needs: build-deploy
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    steps:
      - name: Deployment Success Notification
        if: needs.build-deploy.result == 'success'
        run: |
          echo "Deployment successful!"
          echo "Environment: ${{ needs.build-deploy.outputs.environment }}"
          echo "URL: ${{ needs.build-deploy.outputs.url }}"

      - name: Deployment Failure Notification
        if: needs.build-deploy.result == 'failure'
        run: |
          echo "Deployment failed!"
          echo "Check logs at: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
